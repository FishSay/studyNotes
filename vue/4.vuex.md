



## 下载与配置（）

```javascript
npm install vuex --save
npm install vuex-persistedstate // 数据持久化
```

src下新建store文件夹,其中新建index.js,如果叫其他的名字，在main.js中引用就要写成`import store from './store/名字'`

```javascript
import Vue from 'vue'
import Vuex from 'vuex'
import createPersistedState from 'vuex-persistedstate'
Vue.use(Vuex)

const store = new Vuex.Store({
    state: {
		listshop: [] // 键值对形式
    },
    mutations: { // 必须同步执行
        名字(state, data) {// state 是旧值, data是传进来的值
            return {...state，listshop:data}
        }
        
        // 一个参数的时候是state
        
        // 不好的写法:
        //名字(state, data) {// state 是旧值, data是传进来的值
           // state.listshop = data 这里的state值得是第一个参数，而非上面的state：{},但是,我认为这个state参数就是未修改之前的state:{}
        //}
    },
    actions: { // 异步执行操作用的,主要用来执行mutations中的指令
        函数名({commit}) { // 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）
            // Action 通过 store.dispatch 方法触发
            // 我们可以在 action 内部执行异步操作
            commit()
        }
    },
	plugins: [createPersistedState()]
})

export default store;
```

vue入口方法main.js需要加上`import store from './store'`,并在`new Vue`中加上store,这样在页面中就可以用this.$store命令

```js
const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
})
```

```javascript

// 页面
mounted() {
        this.$store.commit('test', '123')

    },
    methods: {
        getChild() {
            console.log(this.$store);
        }
    }

// store

state: {
		listshop: [] 
    },
    mutations: {
        test(state, data) {
            return {...state，listshop:data}
        }
    },
```



```javascript
// 在mounted中log(this.$store)
// 结果

Store {_committing: false, _actions: {…}, _actionSubscribers: Array(0), _mutations: {…}, _wrappedGetters: {…}, …}
commit: ƒ boundCommit(type, payload, options)
dispatch: ƒ boundDispatch(type, payload)
getters: {}
registerModule: (t,r,n)=> {…}
replaceState: t=>{u.initialState=f(t),n(t)}
strict: false
unregisterModule: t=> {…}
_actionSubscribers: []
_actions: {}
_committing: false
_devtoolHook: {Vue: ƒ, _buffer: Array(3), _replayBuffer: ƒ, on: ƒ, once: ƒ, …}
_modules: ModuleCollection {root: Module}
_modulesNamespaceMap: {}
_mutations: {}
_subscribers: (2) [ƒ, ƒ]
_vm: Vue {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
_watcherVM: Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
_wrappedGetters: {}
state: (...)
__proto__: Object
```

**注意**:其中的commit是执行store中mutations的指令,第一个参数是自己起的指令的名字,第二个参数是要传到仓库中的参数



存进去的数据在log出来的state里



**由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。**

Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。`getters: {}`

Getter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：

```js
store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]
```
Getter 也可以接受其他 getter 作为第二个参数：
```js
getters: {
  // ...
  doneTodosCount: (state, getters) => {
    return getters.doneTodos.length
  }
}
```

## 你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：

Actions 支持同样的载荷方式和对象方式进行分发

```js
// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}
store.commit('increment', 10)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
```

### 对象风格的提交方式

提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：

```js
store.commit({
  type: 'increment',
  amount: 10
})
```

当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：

```js
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
```

### ## 项目结构

Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：

1. 应用层级的状态应该集中到单个 store 对象中。
2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。
3. 异步逻辑都应该封装到 **action** 里面。

只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。

对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：

```bash
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```



# 主要内容

## state 单一状态树

作为一个“唯一数据源 ([SSOT](https://en.wikipedia.org/wiki/Single_source_of_truth))”而存在。这也意味着，每个应用将仅仅包含一个 store 实例

由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在[计算属性](https://cn.vuejs.org/guide/computed.html)中返回某个状态：

```js
// 创建一个 Counter 组件
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```

### `mapState` 辅助函数

[mapState 辅助函数](https://vuex.vuejs.org/zh/guide/state.html)

```js
// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 基本使用方法 computed函数名：state参数 => store中state里的数据
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`-函数名：store中state里的数据
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}
```

当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。（用法知道，没搞懂咋用）

```js
computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])
```

#### mapState与局部计算属性混用

```js
computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```

## Getter

就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。

Getter 接受 state 作为其第一个参数：

```js
const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done) // 返回done属性值为true的
    }
  }
})
```

Getter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：

```js
store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]
```

Getter 也可以接受其他 getter 作为第二个参数：（没搞懂什么情况下用）

```js
getters: {
  // ...
  doneTodosCount: (state, getters) => {
    return getters.doneTodos.length
  }
}
store.getters.doneTodosCount // -> 1
```

### [`mapGetters` 辅助函数](https://vuex.vuejs.org/zh/guide/getters.html)

`mapGetters` 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性



## Mutation

更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。

```js
state: {
	count: 0
}
```



```js
名字(state) {// 这里的state值得是第一个参数，而非上面的state：{},但是,我认为这个state参数其实就是指未修改之前的state:{}
           state.count++
}
```

在页面中使用`store.commit('Mutation中的函数名')`触发

### 提交载荷（Payload）

意思就是除了固定的state,还可以加个参数,这个参数就是传来的值,这就叫mutation 的 **载荷（payload）**

```js
名字(state, data) {
    state.count = data
}

// store.commit('increment', 10)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}

store.commit('increment', {
  amount: 10
})
```

### 对象风格的提交方式

可以直接包含'type'属性

```js
store.commit({
  type: 'increment',
  amount: 10
})
```

<div style="color: red;"><strong>注：Mutation 中的方法必须是同步函数,在 Vuex 中，mutation 都是同步事务</strong></div>

# Action

Action 类似于 mutation，不同在于：

- Action 提交的是 mutation，而不是直接变更状态。
- Action 可以包含任意异步操作

```js
const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) { 
      context.commit('increment')
    }
  }
})
```



Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个 mutation，或者通过 `context.state` 和 `context.getters` 来获取 state 和 getters。当我们在之后介绍到 [Modules](https://vuex.vuejs.org/zh/guide/modules.html) 时，你就知道 context 对象为什么不是 store 实例本身了。

实践中，我们会经常用到 ES2015 的 [参数解构](https://github.com/lukehoban/es6features#destructuring) 来简化代码（特别是我们需要调用 `commit` 很多次的时候）：

```js
actions: {
  increment ({ commit }) {
    commit('increment')
  }
}
```

### 分发 Action

* Action 通过 `store.dispatch` 方法触发

* Actions 支持同样的载荷方式和对象方式进行分发：

### 组合 Action

[组合 Action](https://vuex.vuejs.org/zh/guide/actions.html)

`store.dispatch` 可以处理被触发的 action 的处理函数返回的 Promise，并且 `store.dispatch` 仍旧返回 Promise,

意思就是可以和Promise搭配着用

# Module

由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：

```js
const moduleA = {
  state: { ... },
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: { ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

### 模块的局部状态

* 对于模块内部的 mutation 和 getter，接收的第一个参数是**本模块内的**。

* 对于模块内部的 getter、actions，根节点状态会作为第三个参数暴露出来，actions根节点状态则为 `context.rootState`

  ```js
  const moduleA = {
    // ...
    actions: {
      incrementIfOddOnRootSum ({ state, commit, rootState }) {
        if ((state.count + rootState.count) % 2 === 1) {
          commit('increment')
        }
      }
    }
  }
  ```

  对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：

  ```js
  const moduleA = {
    // ...
    getters: {
      sumWithRootCount (state, getters, rootState) {
        return state.count + rootState.count
      }
    }
  }
  ```

### [命名空间](https://vuex.vuejs.org/zh/guide/modules.html)(暂时还不明白)

