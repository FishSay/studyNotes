## 下载与配置

```javascript
npm install vuex --save
npm install vuex-persistedstate // 数据持久化
```

src下新建store文件夹,其中新建index.js,如果叫其他的名字，在main.js中引用就要写成`import store from './store/名字'`

```javascript
import Vue from 'vue'
import Vuex from 'vuex'
import createPersistedState from 'vuex-persistedstate'
Vue.use(Vuex)

const store = new Vuex.Store({
    state: {
		listshop: [] // 键值对形式
    },
    mutations: { // 必须同步执行
        名字(state, data) {// state 是旧值, data是传进来的值
            return {...state，listshop:data}
        }
        
        // 不好的写法:
        //名字(state, data) {// state 是旧值, data是传进来的值
           // state.listshop = data
        //}
    },
    actions: { // 异步执行操作用的,主要用来执行mutations中的指令
        函数名({commit}) { // 实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）
            // Action 通过 store.dispatch 方法触发
            // 我们可以在 action 内部执行异步操作
            commit()
        }
    },
	plugins: [createPersistedState()]
})

export default store;
```

vue入口方法main.js需要加上`import store from './store'`,并在`new Vue`中加上store,这样在页面中就可以用this.$store命令

```javascript

// 页面
mounted() {
        this.$store.commit('test', '123')

    },
    methods: {
        getChild() {
            console.log(this.$store);
        }
    }

// store

state: {
		listshop: [] 
    },
    mutations: {
        test(state, data) {
            return {...state，listshop:data}
        }
    },
```



```javascript
// 在mounted中log(this.$store)
// 结果

Store {_committing: false, _actions: {…}, _actionSubscribers: Array(0), _mutations: {…}, _wrappedGetters: {…}, …}
commit: ƒ boundCommit(type, payload, options)
dispatch: ƒ boundDispatch(type, payload)
getters: {}
registerModule: (t,r,n)=> {…}
replaceState: t=>{u.initialState=f(t),n(t)}
strict: false
unregisterModule: t=> {…}
_actionSubscribers: []
_actions: {}
_committing: false
_devtoolHook: {Vue: ƒ, _buffer: Array(3), _replayBuffer: ƒ, on: ƒ, once: ƒ, …}
_modules: ModuleCollection {root: Module}
_modulesNamespaceMap: {}
_mutations: {}
_subscribers: (2) [ƒ, ƒ]
_vm: Vue {_uid: 1, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
_watcherVM: Vue {_uid: 0, _isVue: true, $options: {…}, _renderProxy: Proxy, _self: Vue, …}
_wrappedGetters: {}
state: (...)
__proto__: Object
```

**注意**:其中的commit是执行store中mutations的指令,第一个参数是自己起的指令的名字,第二个参数是要传到仓库中的参数



存进去的数据在log出来的state里



**由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation。**

Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。`getters: {}`

Getter 会暴露为 `store.getters` 对象，你可以以属性的形式访问这些值：

```js
store.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]
```
Getter 也可以接受其他 getter 作为第二个参数：
```js
getters: {
  // ...
  doneTodosCount: (state, getters) => {
    return getters.doneTodos.length
  }
}
```

## 你可以向 `store.commit` 传入额外的参数，即 mutation 的 **载荷（payload）**：

Actions 支持同样的载荷方式和对象方式进行分发

```js
// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}
store.commit('increment', 10)
```

在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：

```js
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
store.commit('increment', {
  amount: 10
})
```

### 对象风格的提交方式

提交 mutation 的另一种方式是直接使用包含 `type` 属性的对象：

```js
store.commit({
  type: 'increment',
  amount: 10
})
```

当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：

```js
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
```

### ## 项目结构

Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：

1. 应用层级的状态应该集中到单个 store 对象中。
2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。
3. 异步逻辑都应该封装到 **action** 里面。

只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。

对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：

```bash
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```